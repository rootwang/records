# 官网
https://doris.apache.org/zh-CN/docs/table-design/index/index-overview
本文基于2.1版本
# 特性

*   数据库
*   基于MPP架构
*   实时
*   支持高并发(亚秒 级)和高吞吐的复杂分析
*   2017年百度开源，18年贡献给apache
*   Doris并非DorisDB，DorisDB是百度团队离职人员搞的一个，后期改名starrocks，但框架是一样的

# 使用场景

*   使用实时采集工具，比如CDC、Flink、Spark等实时写入
*   数据湖联邦查询，通过外表的方式连接数据湖，进行数据分析，比如Iceberg等
*   报表分析
*   即席查询(秒级延迟查询)
*   机器学习

其实和Clickhouse是同级的。

# 架构

![[Pasted image 20241208122035.png]]
> Frontend：负责数据接入、SQL解析,分成leader、follower 和 observer，
> - leader负责管理Frontend、接入请求、元数据管理和查询请求等
> - follower：backup leader
> - observer：分担leader的压力，负责客户端的查询请求、同步leader元数据
> 
> BackEnd：存储表、查询计划的执行
> 
> Broker(可选)：还可以部署Broker可选进程，主要用于支持Doris读写远端存储上的文件和目录。例如：Apache HDFS 、阿里云OSS、亚马逊S3等。
> 通过提供一个 RPC 服务端口来提供服务，是一个无状态的 Java 进程，负责为远端存储的读写操作封装一些类 POSIX 的文件操作，如 open，pread，pwrite 等等。除此之外，Broker 不记录任何其他信息，所以包括远端存储的连接信息、文件信息、权限信息等等，都需要通过参数在 RPC 调用中传递给 Broker 进程，才能使得 Broker 能够正确读写文件。Broker 仅作为一个数据通路，并不参与任何计算，因此仅需占用较少的内存。通常一个 Doris 系统中会部署一个或多个 Broker 进程。

BE分布式的存储Doris table表数据，table表数据会经过分区分桶形成tablet，**tablet采用列式存储，默认有3个副本**。BE会接收FE命令来创建、查询、删除table表，接收来自FE的执行计划并分布式执行。BE会通过索引和谓词下推快速过滤数据，可以在后台执行Compact任务，减少查询时的读放大。

# 特性
1、采用 MySQL 协议，高度兼容 MySQL 语法，支持标准 SQL
2、列式存储
3、支持丰富的索引结构
```
- Sorted Compound Key Index，可以最多指定三个列组成复合排序键，通过该索引，能够有效进行数据裁剪，从而能够更好支持高并发的报表场景。
- Z-order Index ：使用 Z-order 索引，可以高效对数据模型中的任意字段组合进行范围查询。
- Min/Max ：有效过滤数值类型的等值和范围查询。
- Bloom Filter ：对高基数列的等值过滤裁剪非常有效。
- Invert Index ：能够对任意字段实现快速检索。
```
4、支持多种存储模型，就是表的功能
Doris 支持多种存储模型，针对不同的场景做了针对性的优化：
- Aggregate Key 模型：相同 Key 的 Value 列合并，通过提前聚合大幅提升性能。
- Unique Key 模型：Key 唯一，相同 Key 的数据覆盖，实现行级别数据更新。
- Duplicate Key 模型：明细数据模型，满足事实表的明细存储。
5、支持物化视图：会将查询结果存储下来
6、支持向量化查询引擎
![[Pasted image 20241208164645.png]]
**向量化执行，可以简单地看作一项消除程序中循环的优化。** 这里用一个形象的例子比喻。小胡经营了一家果汁店，虽然店里的鲜榨苹果汁深受大家喜爱，但客户总是抱怨制作果汁的速度太慢。小胡的店里只有一台榨汁机，每次他都会从篮子里拿出一个苹果，放到榨汁机内等待出汁。如果有8个客户，每个客户都点了一杯苹果汁，那么小胡需要重复循环8次上述的榨汁流程，才能榨出8杯苹果汁。如果制作一杯果汁需要5分钟，那么全部制作完毕则需要40分钟。为了提升果汁的制作速度，小胡想出了一个办法。他将榨汁机的数量从1台增加到了8台，这么一来，他就可以从篮子里一次性拿出8个苹果，分别放入8台榨汁机同时榨汁。此时，小胡只需要5分钟就能够制作出8杯苹果汁。**为了制作n杯果汁，非向量化执行的方式是用1台榨汁机重复循环制作n次，而向量化执行的方式是用n台榨汁机只执行1次。**
![[Pasted image 20241208165640.png]]
为了实现向量化执行，需要利用CPU的SIMD指令，SIMD的全称是Single Instruction Multiple Data，即用单条指令操作多条数据。现代计算机系统概念中，它是通过数据并行以提高性能的一种实现方式(其他的还有指令级并行和线程级并行)，它的原理是在CPU寄存器层面实现数据的并行操作。
Doris 查询引擎是向量化的查询引擎，所有的内存结构能够按照列式布局，能够达到大幅减少虚函数调用、提升 Cache 命中率，高效利用 SIMD 指令的效果。在宽表聚合场景下性能是非向量化引擎的 5-10 倍。
7、支持CBO和RBO 查询优化器，简单来说都采用CBO，RBO即按规则制定计划，CBO会根据实时的IO等情况综合得出当前的最优执行计划，即RBO比较死板，CBO比较灵活。
![[Pasted image 20241208165909.png]]
在SQL优化器中最重要的一个组件是查询优化器（Query Optimization），在海量数据分析中一条SQL生成的执行计划搜索空间非常庞大，查询优化器的目的就是对执行计划空间进行裁剪减少搜索空间的代价，查询优化器对于SQL的执行来说非常重要，不管是关系型数据库系统Oracle、MySQL还是大数据领域中的Hive、SparkSQL、Flink SQL都会有一个查询优化器进行SQL执行计划优化。
有的数据库系统会采用自研的查询优化器，而有的则会采用开源的查询优化器插件，比如Apache Calcite就是一个优秀的开源查询优化器插件。而像Oracle数据库的查询优化器，则是Oracle公司自研的一个核心组件，负责解析SQL，其目的是按照一定的原则来获取目标SQL在当前情形下执行的最高效执行路径。
查询优化器主要解决的是多个连接操作的复杂查询优化，负责生成、制定SQL的执行计划，目前主要有2种查询优化器：基于规则的优化器（RBO）与基于代价的优化器（CBO），下面分别大致了解RBO和CBO优化器原理:
- **RBO(Rule-Based Optimization):**
RBO即基于规则的优化器，该优化器按照硬编码在数据库中的一系列规则来决定SQL的执行计划，只要求我们按照这套规则来写SQL语句，无论表中的数据分布和数据量如何都不会影响这套规则下的执行计划。以Oracle数据库为例，RBO根据Oracle指定的优先顺序规则，对指定的表进行执行计划的选择。比如在规则中：索引的优先级大于全表扫描。
通过以上可以了解到在RBO对数据不“敏感”，但在实际的场景中，数据的量级以及数据的分布会严重影响同样的SQL执行性能，这也是RBO的缺点所在，所以RBO生成的执行计划往往不是最优的。
- **CBO(Cost-Based Optimization)：**
CBO即基于代价的优化器，该优化器通过根据优化规则对关系表达式进行转换，按照表、索引、列等信息生成多个执行计划，然后CBO会通过根据统计信息(Statistics)和代价模型(Cost Model)计算各种可能“执行计划”的“代价”，即COST，从中选用COST最低的执行方案，作为实际运行方案。
CBO依赖数据库对象的统计信息，这些信息包括：SQL执行路径的I/O，网络开销、CPU使用情况等，目前各大数据库和大数据的计算引擎都倾向于使用CBO，或者 **两者结合（可以基于两者选择最优的执行计划，提高效率）** 。像在Oracle10g开始彻底放弃了RBO，MySQL使用的也是CBO优化器；在大数据领域中 Hive也在0.14版本引入CBO，Spark计算框架使用的是Catalyst查询引擎（基于Scala开发），这种查询引擎支持RBO和CBO优化器，Flink计算框架使用的是Calcite查询引擎（开源），这种查询引擎也是同时支持RBO和CBO优化器。
同样，Doris中在优化器方面也是使用 CBO 和 RBO 结合的优化策略，RBO 支持常量折叠、子查询改写、谓词下推等，CBO 支持 Join [Reorder](https://cloud.fynote.com/share/)。目前 CBO 还在持续优化中，主要集中在更加精准的统计信息收集和推导，更加精准的代价模型预估等方面。
8、动态调整执行计划，这个主要是得益于CBO
Doris 采用了 Adaptive Query Execution 技术， 可以根据 Runtime Statistics 来动态调整执行计划，比如通过 Runtime Filter 技术能够在运行时生成 Filter 推到 Probe 侧，并且能够将 Filter 自动穿透到 Probe 侧最底层的 Scan 节点，从而大幅减少 Probe 的数据量，加速 Join 性能。Doris 的 Runtime Filter 支持 In/Min/Max/Bloom Filter。